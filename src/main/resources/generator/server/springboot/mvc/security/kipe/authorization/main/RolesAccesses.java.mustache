package {{packageName}}.shared.kipe.domain;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import {{packageName}}.shared.authentication.domain.Role;
import {{packageName}}.shared.authentication.domain.Roles;
import {{packageName}}.shared.error.domain.Assert;
import {{packageName}}.shared.kipe.domain.Accesses.RoleAccessesBuilder;

public final class RolesAccesses {

  private final Map<Role, Accesses> roles;

  private RolesAccesses(RolesAccessesBuilder builder) {
    roles = builder.roles.entrySet().stream().collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, entry -> entry.getValue().build()));
  }

  private RolesAccesses(Map<Role, Accesses> roles) {
    this.roles = roles;
  }

  public static RolesAccessesBuilder builder() {
    return new RolesAccessesBuilder();
  }

  public static RolesAccesses empty() {
    return builder().build();
  }

  public boolean allAuthorized(Roles userRoles, Action action, Resource resource) {
    Assert.notNull("userRoles", userRoles);
    Assert.notNull("action", action);
    Assert.notNull("resource", resource);

    return userRoles.stream().anyMatch(allAuthorized(action, resource));
  }

  private Predicate<Role> allAuthorized(Action action, Resource resource) {
    return role -> {
      var accesses = roles.get(role);

      if (accesses == null) {
        return false;
      }

      return accesses.allAuthorized(action, resource);
    };
  }

  public boolean specificAuthorized(Roles userRoles, Action action, Resource resource) {
    Assert.notNull("userRoles", userRoles);
    Assert.notNull("action", action);
    Assert.notNull("resource", resource);

    return userRoles.stream().anyMatch(specificAuthorized(action, resource));
  }

  public Map<Role, Accesses> getRoles() {
    return roles;
  }

  private Predicate<Role> specificAuthorized(Action action, Resource resource) {
    return role -> {
      var accesses = roles.get(role);

      if (accesses == null) {
        return false;
      }

      return accesses.specificAuthorized(action, resource);
    };
  }

  public RolesAccesses merge(RolesAccesses other) {
    Assert.notNull("other", other);

    Map<Role, Accesses> mergedRoles = Stream.concat(roles.entrySet().stream(), other.roles.entrySet().stream()).collect(
      Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue, Accesses::merge)
    );

    return createFromMap(mergedRoles);
  }

  private static RolesAccesses createFromMap(Map<Role, Accesses> roles) {
    return new RolesAccesses(roles);
  }

  public static final class RolesAccessesBuilder {

    private final Map<Role, RoleAccessesBuilder> roles = new ConcurrentHashMap<>();

    private RolesAccessesBuilder() {}

    public RoleAccessesBuilder role(Role role) {
      Assert.notNull("role", role);

      return roles.computeIfAbsent(role, key -> Accesses.builder(this));
    }

    public RolesAccesses build() {
      return new RolesAccesses(this);
    }
  }
}
